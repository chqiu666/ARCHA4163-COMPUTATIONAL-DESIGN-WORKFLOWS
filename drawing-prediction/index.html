<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Drawing with SketchRNN</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            height: 100vh;
        }

        #canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            background: white;
            cursor: crosshair;
        }

        #video {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border: 2px solid #fff;
            border-radius: 8px;
            z-index: 100;
        }

        .controls {
            position: absolute;
            left: 20px;
            top: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            background: #fff;
            color: #333;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            min-width: 120px;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }

        .button.active {
            background: #667eea;
            color: white;
        }

        .clear-btn {
            background: #ff6b6b !important;
            color: white !important;
            margin-bottom: 20px;
        }

        .clear-btn:hover {
            background: #ff5252 !important;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.5;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            z-index: 100;
        }

        .status {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 100;
        }

        .gesture-indicator {
            position: absolute;
            top: 160px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 15px;
            font-size: 12px;
            z-index: 100;
            min-width: 100px;
            text-align: center;
        }

        .debug-info {
            position: absolute;
            bottom: 200px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 11px;
            z-index: 100;
            max-width: 200px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <video id="video" autoplay muted></video>
    
    <div class="controls">
        <button class="button clear-btn" onclick="clearCanvas()">Clear Canvas</button>
        <button class="button category-btn" data-category="random" onclick="selectCategory('random')">Random</button>
        <button class="button category-btn" data-category="flower" onclick="selectCategory('flower')">Flower</button>
        <button class="button category-btn" data-category="cat" onclick="selectCategory('cat')">Cat</button>
        <button class="button category-btn" data-category="pig" onclick="selectCategory('pig')">Pig</button>
        <button class="button category-btn" data-category="face" onclick="selectCategory('face')">Face</button>
    </div>

    <div class="status" id="status">Loading models...</div>
    <div class="gesture-indicator" id="gesture">No hand detected</div>
    <div class="debug-info" id="debug">
        Camera: Not initialized<br>
        HandPose: Not loaded<br>
        SketchRNN: Not loaded
    </div>

    <div class="instructions">
        <strong>Hand Gesture Controls:</strong><br>
        üëâ <strong>Point with index finger</strong> - Draw on canvas<br>
        ü§è <strong>Pinch (thumb + index finger)</strong> - Click buttons<br>
        ‚úã <strong>Open palm</strong> - Clear canvas<br>
        üé® <strong>AI Drawing:</strong> After drawing a few strokes, the AI will complete your drawing based on the selected category.<br><br>
        <strong>Troubleshooting:</strong> If camera doesn't work, check browser permissions, ensure you're on localhost or HTTPS, and try refreshing.
        <button onclick="retrySetup()" style="margin-top: 10px; padding: 5px 10px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer;">Retry Camera Setup</button>
    </div>

    <!-- TensorFlow.js -->
    <script src="https://unpkg.com/@tensorflow/tfjs-core@3.7.0/dist/tf-core.js"></script>
    <script src="https://unpkg.com/@tensorflow/tfjs-backend-webgl@3.7.0/dist/tf-backend-webgl.js"></script>
    
    <!-- MediaPipe Handpose -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.0/dist/hand-pose-detection.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.min.js"></script>
    
    <!-- ml5.js -->
    <script src="https://unpkg.com/ml5@latest/dist/ml5.min.js"></script>

    <script>
        // Global variables
        let handpose;
        let video;
        let predictions = [];
        let canvas, ctx;
        let isDrawing = false;
        let lastX = 0, lastY = 0;
        let sketchRNN;
        let currentCategory = 'flower';
        let strokePath = [];
        let allStrokes = [];
        let lastGesture = '';
        let gestureStartTime = 0;
        const GESTURE_DELAY = 1000; // 1 second delay to prevent accidental triggers

        // Available SketchRNN categories
        const categories = ['flower', 'cat', 'pig', 'face'];
        
        // Initialize the application
        async function setup() {
            // Setup canvas
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            
            // Setup video
            video = document.getElementById('video');
            
            // Setup drawing context
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            try {
                // Initialize webcam
                updateStatus('Requesting camera access...');
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    }
                });
                
                video.srcObject = stream;
                
                // Wait for video to be ready
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play().then(resolve).catch(resolve);
                    };
                });
                
                updateStatus('Camera ready, loading hand tracking...');
                updateDebugInfo();
                
                // Wait a bit more to ensure video is fully loaded
                setTimeout(async () => {
                    try {
                        // Initialize handpose
                        handpose = ml5.handpose(video, modelReady);
                        handpose.on('predict', gotHands);
                        
                        // Initialize SketchRNN with flower model
                        await loadSketchRNN(currentCategory);
                        
                    } catch (error) {
                        console.error('Error loading models:', error);
                        updateStatus('Error loading AI models. Please refresh the page.');
                    }
                }, 1000);
                
            } catch (error) {
                console.error('Error initializing camera:', error);
                if (error.name === 'NotAllowedError') {
                    updateStatus('Camera access denied. Please allow camera permission and refresh.');
                } else if (error.name === 'NotFoundError') {
                    updateStatus('No camera found. Please connect a camera and refresh.');
                } else {
                    updateStatus('Error accessing camera: ' + error.message);
                }
            }
        }

        function modelReady() {
            console.log('Handpose model ready!');
            updateStatus('Hand tracking ready! Show your hand to start drawing.');
            updateDebugInfo();
        }

        async function loadSketchRNN(category) {
            updateStatus(`Loading ${category} model...`);
            try {
                // Use the updated ml5.js SketchRNN API
                sketchRNN = await ml5.sketchRNN(category);
                console.log(`SketchRNN ${category} model loaded successfully`);
                updateStatus(`Ready! ${currentCategory} AI model loaded. Show your hand to start drawing.`);
                updateDebugInfo();
            } catch (error) {
                console.error('Error loading SketchRNN:', error);
                updateStatus(`Error loading ${category} AI model. Using basic drawing mode.`);
                sketchRNN = null; // Set to null so we know it failed
                updateDebugInfo();
            }
        }

        function sketchRNNReady() {
            // This function is no longer needed with the async/await approach
            updateStatus(`Ready! ${currentCategory} AI model loaded. Show your hand to start drawing.`);
            updateDebugInfo();
        }

        function gotHands(results) {
            predictions = results;
            
            if (predictions.length > 0) {
                const hand = predictions[0];
                analyzeGesture(hand);
                drawHandPoints(hand);
            } else {
                document.getElementById('gesture').textContent = 'No hand detected';
            }
        }

        function analyzeGesture(hand) {
            const landmarks = hand.landmarks;
            
            // Get key points
            const indexTip = landmarks[8];
            const indexPip = landmarks[6];
            const thumbTip = landmarks[4];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const wrist = landmarks[0];
            
            // Convert to canvas coordinates
            const indexX = indexTip[0];
            const indexY = indexTip[1];
            
            // Calculate distances for gesture recognition
            const thumbIndexDist = distance(thumbTip, indexTip);
            const indexMiddleDist = distance(indexTip, middleTip);
            const fingersUp = countFingersUp(landmarks);
            
            let currentGesture = '';
            
            // Gesture detection logic
            if (thumbIndexDist < 40) {
                // Pinch gesture (thumb and index close)
                currentGesture = 'pinch';
                handlePinchGesture(indexX, indexY);
            } else if (fingersUp >= 4) {
                // Open palm (4 or more fingers up)
                currentGesture = 'palm';
                handlePalmGesture();
            } else if (fingersUp === 1 && isFingerUp(landmarks, 1)) {
                // Index finger pointing
                currentGesture = 'point';
                handlePointingGesture(indexX, indexY);
            } else {
                currentGesture = 'none';
                if (isDrawing) {
                    finishStroke();
                }
            }
            
            // Update gesture indicator with delay for stability
            if (currentGesture !== lastGesture) {
                lastGesture = currentGesture;
                gestureStartTime = Date.now();
            }
            
            // Update display
            const gestureNames = {
                'pinch': 'ü§è Pinch (Click)',
                'palm': '‚úã Open Palm (Clear)',
                'point': 'üëâ Pointing (Draw)',
                'none': '‚úä No gesture'
            };
            
            document.getElementById('gesture').textContent = gestureNames[currentGesture] || 'Detecting...';
        }

        function countFingersUp(landmarks) {
            let count = 0;
            
            // Thumb
            if (landmarks[4][0] > landmarks[3][0]) count++;
            
            // Other fingers
            const fingerTips = [8, 12, 16, 20];
            const fingerPips = [6, 10, 14, 18];
            
            for (let i = 0; i < fingerTips.length; i++) {
                if (landmarks[fingerTips[i]][1] < landmarks[fingerPips[i]][1]) {
                    count++;
                }
            }
            
            return count;
        }

        function isFingerUp(landmarks, fingerIndex) {
            const tips = [4, 8, 12, 16, 20];
            const pips = [3, 6, 10, 14, 18];
            
            if (fingerIndex === 0) {
                // Thumb
                return landmarks[tips[0]][0] > landmarks[pips[0]][0];
            } else {
                // Other fingers
                return landmarks[tips[fingerIndex]][1] < landmarks[pips[fingerIndex]][1];
            }
        }

        function handlePointingGesture(x, y) {
            if (!isDrawing) {
                startDrawing(x, y);
            } else {
                continueDrawing(x, y);
            }
        }

        function handlePinchGesture(x, y) {
            if (Date.now() - gestureStartTime > GESTURE_DELAY) {
                handleButtonClick(x, y);
            }
        }

        function handlePalmGesture() {
            if (Date.now() - gestureStartTime > GESTURE_DELAY) {
                clearCanvas();
            }
        }

        function handleButtonClick(x, y) {
            // Check if cursor is over any button
            const buttons = document.querySelectorAll('.button');
            buttons.forEach(button => {
                const rect = button.getBoundingClientRect();
                if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                    button.click();
                }
            });
        }

        function startDrawing(x, y) {
            isDrawing = true;
            lastX = x;
            lastY = y;
            strokePath = [[x, y]];
            
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        function continueDrawing(x, y) {
            if (!isDrawing) return;
            
            ctx.lineTo(x, y);
            ctx.stroke();
            
            strokePath.push([x, y]);
            lastX = x;
            lastY = y;
        }

        function finishStroke() {
            if (!isDrawing) return;
            
            isDrawing = false;
            if (strokePath.length > 5) {
                allStrokes.push(strokePath);
                
                // Trigger AI completion after a few strokes
                if (allStrokes.length >= 3) {
                    generateAICompletion();
                }
            }
            strokePath = [];
        }

        async function generateAICompletion() {
            if (!sketchRNN) {
                console.log('SketchRNN not loaded, using fallback completion');
                generateFallbackCompletion();
                return;
            }
            
            try {
                updateStatus('Generating AI completion...');
                
                // For the new ml5.js API, we can either:
                // 1. Generate from existing strokes (if supported)
                // 2. Or generate a new drawing from scratch
                
                // Try to generate a new drawing
                const result = await sketchRNN.generate();
                
                if (result && result.length > 0) {
                    drawRNNStrokes(result);
                    updateStatus('AI completion added!');
                } else {
                    console.log('No result from SketchRNN generation, using fallback');
                    generateFallbackCompletion();
                }
                
            } catch (error) {
                console.error('Error generating AI completion:', error);
                updateStatus('AI completion failed, using simple completion');
                generateFallbackCompletion();
            }
        }

        function generateFallbackCompletion() {
            // Simple geometric completion based on category
            const completions = {
                'flower': drawSimpleFlower,
                'cat': drawSimpleCat,
                'pig': drawSimplePig,
                'face': drawSimpleFace
            };
            
            const drawFunction = completions[currentCategory] || drawSimpleFlower;
            drawFunction();
            updateStatus('Simple completion added!');
        }

        function drawSimpleFlower() {
            const centerX = lastX || canvas.width / 2;
            const centerY = lastY || canvas.height / 2;
            
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            
            // Draw petals
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI * 2) / 8;
                const x1 = centerX + Math.cos(angle) * 30;
                const y1 = centerY + Math.sin(angle) * 30;
                const x2 = centerX + Math.cos(angle) * 60;
                const y2 = centerY + Math.sin(angle) * 60;
                
                ctx.beginPath();
                ctx.arc(x2, y2, 15, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Draw center
            ctx.beginPath();
            ctx.arc(centerX, centerY, 10, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
        }

        function drawSimpleCat() {
            const centerX = lastX || canvas.width / 2;
            const centerY = lastY || canvas.height / 2;
            
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            
            // Head
            ctx.beginPath();
            ctx.arc(centerX, centerY, 40, 0, Math.PI * 2);
            ctx.stroke();
            
            // Ears
            ctx.beginPath();
            ctx.moveTo(centerX - 25, centerY - 25);
            ctx.lineTo(centerX - 15, centerY - 50);
            ctx.lineTo(centerX - 5, centerY - 25);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX + 25, centerY - 25);
            ctx.lineTo(centerX + 15, centerY - 50);
            ctx.lineTo(centerX + 5, centerY - 25);
            ctx.stroke();
            
            // Eyes
            ctx.beginPath();
            ctx.arc(centerX - 15, centerY - 10, 3, 0, Math.PI * 2);
            ctx.arc(centerX + 15, centerY - 10, 3, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
        }

        function drawSimplePig() {
            const centerX = lastX || canvas.width / 2;
            const centerY = lastY || canvas.height / 2;
            
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            
            // Head
            ctx.beginPath();
            ctx.arc(centerX, centerY, 45, 0, Math.PI * 2);
            ctx.stroke();
            
            // Snout
            ctx.beginPath();
            ctx.arc(centerX, centerY + 15, 20, 0, Math.PI * 2);
            ctx.stroke();
            
            // Ears
            ctx.beginPath();
            ctx.arc(centerX - 25, centerY - 25, 15, 0, Math.PI * 2);
            ctx.arc(centerX + 25, centerY - 25, 15, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
        }

        function drawSimpleFace() {
            const centerX = lastX || canvas.width / 2;
            const centerY = lastY || canvas.height / 2;
            
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            
            // Head
            ctx.beginPath();
            ctx.arc(centerX, centerY, 50, 0, Math.PI * 2);
            ctx.stroke();
            
            // Eyes
            ctx.beginPath();
            ctx.arc(centerX - 20, centerY - 15, 5, 0, Math.PI * 2);
            ctx.arc(centerX + 20, centerY - 15, 5, 0, Math.PI * 2);
            ctx.stroke();
            
            // Nose
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - 5);
            ctx.lineTo(centerX - 5, centerY + 5);
            ctx.lineTo(centerX + 5, centerY + 5);
            ctx.stroke();
            
            // Mouth
            ctx.beginPath();
            ctx.arc(centerX, centerY + 5, 20, 0, Math.PI);
            ctx.stroke();
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
        }

        function convertStrokesToRNNFormat(strokes) {
            const rnnStrokes = [];
            
            for (let stroke of strokes) {
                if (stroke.length > 1) {
                    for (let i = 1; i < stroke.length; i++) {
                        const dx = stroke[i][0] - stroke[i-1][0];
                        const dy = stroke[i][1] - stroke[i-1][1];
                        const pen = (i === stroke.length - 1) ? 1 : 0; // Pen up at end of stroke
                        rnnStrokes.push([dx, dy, pen]);
                    }
                }
            }
            
            return rnnStrokes;
        }

        function drawRNNStrokes(strokes) {
            if (!strokes || !Array.isArray(strokes) || strokes.length === 0) {
                console.log('Invalid strokes data:', strokes);
                return;
            }
            
            ctx.strokeStyle = '#ff6b6b'; // Use a different color for AI-generated strokes
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.7; // Make AI strokes slightly transparent
            
            // Start from center of canvas if no previous drawing
            let x = lastX || canvas.width / 2;
            let y = lastY || canvas.height / 2;
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            
            // Handle different possible data formats
            for (let i = 0; i < strokes.length; i++) {
                const stroke = strokes[i];
                
                if (Array.isArray(stroke) && stroke.length >= 2) {
                    // Format: [dx, dy, pen]
                    x += stroke[0] * 2; // Scale up the movements
                    y += stroke[1] * 2;
                    
                    // Keep drawing within canvas bounds
                    x = Math.max(0, Math.min(canvas.width, x));
                    y = Math.max(0, Math.min(canvas.height, y));
                    
                    if (stroke.length >= 3 && stroke[2] === 1) {
                        // Pen up - finish current stroke and start new one
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                    } else {
                        // Pen down - continue drawing
                        ctx.lineTo(x, y);
                    }
                }
            }
            
            ctx.stroke();
            
            // Reset drawing context
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.globalAlpha = 1.0;
        }

        function selectCategory(category) {
            if (category === 'random') {
                currentCategory = categories[Math.floor(Math.random() * categories.length)];
                updateStatus(`Random selection: ${currentCategory}`);
            } else {
                currentCategory = category;
            }
            
            // Update active button
            document.querySelectorAll('.category-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            if (category === 'random') {
                document.querySelector('[data-category="random"]').classList.add('active');
            } else {
                document.querySelector(`[data-category="${category}"]`).classList.add('active');
            }
            
            loadSketchRNN(currentCategory);
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            allStrokes = [];
            strokePath = [];
            isDrawing = false;
            updateStatus('Canvas cleared!');
        }

        function drawHandPoints(hand) {
            // Draw hand landmarks for debugging (optional)
            const landmarks = hand.landmarks;
            
            // Draw index fingertip
            const indexTip = landmarks[8];
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(indexTip[0], indexTip[1], 8, 0, 2 * Math.PI);
            ctx.fill();
        }

        function distance(point1, point2) {
            return Math.sqrt(Math.pow(point1[0] - point2[0], 2) + Math.pow(point1[1] - point2[1], 2));
        }

        function updateStatus(message) {
            document.getElementById('status').textContent = message;
            console.log('Status:', message);
        }

        function updateDebugInfo() {
            const debugElement = document.getElementById('debug');
            const cameraStatus = video && video.readyState === 4 ? 'Ready' : 'Not ready';
            const handposeStatus = handpose ? 'Loaded' : 'Not loaded';
            const sketchRNNStatus = sketchRNN ? 'Loaded' : (sketchRNN === null ? 'Failed' : 'Loading...');
            const handsDetected = predictions.length > 0 ? 'Yes' : 'No';
            
            debugElement.innerHTML = `
                Camera: ${cameraStatus}<br>
                HandPose: ${handposeStatus}<br>
                SketchRNN: ${sketchRNNStatus}<br>
                Category: ${currentCategory}<br>
                Hands: ${handsDetected}<br>
                Strokes: ${allStrokes.length}
            `;
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // Window resize handler
        window.addEventListener('resize', () => {
            resizeCanvas();
        });

        // Check camera availability first
        async function checkCameraAvailability() {
            // Check if we're on HTTPS or localhost
            if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                updateStatus('Camera requires HTTPS. Please use localhost or HTTPS.');
                return false;
            }
            
            // Check if mediaDevices is supported
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                updateStatus('Camera not supported in this browser.');
                return false;
            }
            
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                if (videoDevices.length === 0) {
                    updateStatus('No camera detected. Please connect a camera and refresh.');
                    return false;
                }
                
                return true;
            } catch (error) {
                console.error('Error checking camera:', error);
                updateStatus('Unable to check camera availability.');
                return false;
            }
        }
        
        // Initialize when page loads
        window.addEventListener('load', async () => {
            // Start debug info updates
            setInterval(updateDebugInfo, 2000); // Update every 2 seconds
            
            // First check if camera is available
            const cameraAvailable = await checkCameraAvailability();
            if (cameraAvailable) {
                setup();
            }
        });

        // Retry setup function
        async function retrySetup() {
            updateStatus('Retrying camera setup...');
            
            // Reset variables
            handpose = null;
            sketchRNN = null;
            
            // Stop existing video stream if any
            if (video && video.srcObject) {
                const tracks = video.srcObject.getTracks();
                tracks.forEach(track => track.stop());
                video.srcObject = null;
            }
            
            updateDebugInfo();
            
            // Wait a moment then retry
            setTimeout(async () => {
                const cameraAvailable = await checkCameraAvailability();
                if (cameraAvailable) {
                    setup();
                }
            }, 1000);
        }

        // Set initial category
        selectCategory('flower');
    </script>
</body>
</html>